---
title: 자바스크립트 핵심개념
date: 2024-04
keywords: ["this", "contenxt", "prototype", "closure", "call 메서드", "apply 메서드", "bind 메서드"]
---

## 실행컨텍스트

자바스크립트 코드가 실행되는 환경.

<br />
<br />

실행 컨택스트의 동작은, 동일한 환경에 있는 코드들을 실행할 때 필요한 환경정보를 모아 컨텍스트를 구성하고, 이를 콜 스택에 쌓아놓은 뒤, 가장 위에 있는 컨텍스트와 관련 있는 코드들을 실행하는 것으로 코드의 환경과 순서를 보장한다.

### [01.] 실행 컨텍스트 객체

#### [01-1.] Variable Object

Variable Object는 컨텍스트 내에 정의된 **변수와 함수 선언**을 저장하는 특별한 객체다.

<br />
<br />

함수 표현식은 함수 선언식과 달리 변수 객체에 포함되지 않는다. 함수 선언식은 코드 실행 전에 처리되어 변수 객체에 포함되지만, 함수 표현식은 실행 흐름이 해당 표현식에 도달했을 때 평가되고 생성된다. 전역 실행 컨텍스트의 경우, Variable Object는 전역 환경을 담고 있는 객체다. 이는 전역 변수, 전역 함수 선언, 그리고 전역 객체에 대한 참조를 포함한다.

> **MEMO**
>
> -   자바스크립트 엔진은 소스코드를 평가와 실행 과정으로 나누어 처리한다. 평가과정에는 실행컨텍스트를 생성하고 변수 함수등의 선언문만 먼저 실행하여 생성된 식별자를 키로 실행컨텍스트가 관리하는 스코프(렉시컬 환경의 Environment Record) 에 등록한다.
> -   자바스크립트 엔진이 선언문을 먼저 실행하니까 호이스팅이 일어나는거였어....

#### [01-2.] Activation object

함수가 호출될 때 생성되는 객체. 이 객체는 함수의 실행 컨텍스트의 일부로서, 함수의 매개변수, 지역 변수, 그리고 다른 정보를 담고 있다. 활성 객체는 함수의 실행에 필요한 모든 정보를 포함하며, 함수 실행 동안 해당 함수의 스코프 체인에 추가된다.

#### [01-3.] Scope Chain

스코프 체인은 JavaScript에서 **식별자**의 검색을 위해 사용되는 객체다. 이 체인은 코드가 실행되는 컨텍스트에 따라 식별자의 유효 범위를 결정한다. 이 때, Lexical scope를 따른다.

### [02.] 실행컨텍스트가 콜 스택에 추가되는 조건

-   전역코드 실행
-   함수 호출
-   eval function
-   모듈코드 (import)

> **Eval function**
>
> eval 함수는 자바스크립트에서 문자열로 표현된 자바스크립트 코드를 실행하는 데 사용된다. 이 함수는 전달받은 문자열을 코드로 간주하고, 그 코드를 실행한 후 결과를 반환한다. 하지만 eval 함수의 사용은 보안 문제, 성능 문제, 디버깅의 어려움 등 여러 가지 이유로 권장되지 않는다.

> **MEMO**
>
> -   실행컨텍스트는 자바스크립트 코드를 실행하고 평가하기 위한 환경이다.
> -   코드가 실행되면 실행컨텍스트는 2단계의 과정을 거친다.

## This

자바스크립트에서 this는 현재 실행 컨텍스트에 따라 다르게 해석되는 특수한 키워드. this는 실행 컨텍스트에 따라 바뀌게 되는데, this는
함수가 어떻게 호출되었는지에 따라 값이 달라질 수 있다.

### [01.] This 바인딩 규칙

#### [01-1.] 글로벌필드와 일반적인 함수호출

전역 컨텍스트나 함수 호출에서의 this는 전역객체를 가리킨다. 전역함수는 물론이고 심지어 내부함수의 경우도 this는 외부함수가 아닌 전역객체에 바인딩된다.

        ```js title="this"
        console.log(this); //window

        function choonSik() {
            console.log(this); //window
        }

        choonSik();
        ```

내부함수는 **일반 함수, 메소드, 콜백함수 어디에서 선언되었든 관계없이 this는 전역객체**를 바인딩한다.

#### [01-2.] Method

메소드 내부의 this는 해당 메소드를 소유한 객체, 즉 해당 메소드를 호출한 객체에 바인딩된다.

```js title="method"
let obj = {
    name: "ppark",
    consoleName: function () {
        console.log(this.name); //ppark
    },
};

obj.consoleName();
```

하지만 **메소드 내부 함수는 전역 객체**를 바인딩한다.

```js title="inner function"
let obj = {
    name: "ppark",
    consoleName: function () {
        function innerFunc() {
            console.log(this.name); //undefined
        }
        innerFunc();
    },
};

obj.consoleName();
```

#### [01-3.] 생성자함수

생성자 함수에서 this는 새로 생성되는 인스턴스 객체를 가르킨다.

```js title="constructor function"
function Job(job) {
    this.job = job;
    console.log(this.job); //police
}

let police = new Job("police");
```

#### [01-4.] This value를 지정할 수 있는 함수 메서드

apply, call, bind 메소드를 사용하면, 첫 번째 argument로 전달된 객체를 this로 사용할 수 있다.

##### Call

call() 메서드는 주어진 this 값과 개별적으로 제공된 인수를 사용하여 이 함수를 호출한다.

##### **Syntax**

```js title="call"
function.call(thisArg)
function.call(thisArg, arg1)
function.call(thisArg, arg1, arg2)
```

**Parameters**

`thisArg`

함수를 호출할 때 this로 참조할 값입니다. 함수가 엄격 모드가 아닌 경우, null과 undefined는 전역 객체로 대체되며,
**원시 값은 객체**로 변환됩니다.

<br />

`arg1, …, argN` <CustomOption/>

Arguments for the function.

<br />
<br />

**Return**

지정된 `this`값과 aruments로 함수를 호출한 결과

<br />
<br />

**Example**

```js title="call constructor function"
function Product(name, price) {
    this.name = name;
    this.price = price;
}

function Food(name, price) {
    Product.call(this, name, price);
    this.category = "food";
}

console.log(new Food("cheese", 5).name);
// "cheese"
```

```js title="call function"
function product(name, price) {
    this.name = name;
    this.price = price;
    console.log(this);
    // String {"cheese", name:5, price:undefined}
}

function food(name, price) {
    product.call(name, price);
    this.category = "food";
    console.log(this);
    // window
}

console.log(food("cheese", 5));
```

> **MEMO**
>
> -   Call method는 func 인스턴스 메서드이므로 함수에서만 사용.
> -   this 바인딩 규칙에 따라 this 값이 변하기 때문에, this 키워드를 사용하려면 주의해야된다.

##### Apply

`apply()` 메서드는 `call` 메서드와 다르게 **인수 배열 하나**를 받는다는 점이 중요한 차이다. `apply` 메서드는 배열
형태의 인자를 함수에 전달해야 할 때 유용하게 사용되며, 특히 **가변적인 수의 인자를 다룰 때** 자주 사용된다.

##### **Syntax**

```js title="apply"
func.apply(thisArg, [argsArray]);
```

**Parameters**

`thisArg`

`thisArg`는 함수 내부에서 this로 사용될 값. 메소드가 non-strict mode 코드의 함수일 경우, null과 undefined가 전역 객체로 대체.옵션

<br />

`[argsArray]` <CustomOption/>

함수에 전달될 인자들의 배열 또는 유사 배열. 옵션

<br />
<br />

**Return**

지정된 `this`값과 aruments배열로 함수를 호출한 결과

<br />
<br />

**Example**

###### 배열에 배열 더하기

```js title="apply"
var array = ["a", "b"];
var elements = [0, 1, 2];
array.push.apply(array, elements);
console.info(array); // ["a", "b", 0, 1, 2]
```

```js title="only push"
var array = ["a", "b"];
var elements = [0, 1, 2];
array.push(array, elements);
console.info(array); // ['a', 'b', Array(3)]
```

##### Bind

`bind()` 메소드가 호출되면 새로운 함수를 생성합니다. 받게되는 첫 인자의 value로는 `this` 키워드를 설정하고, 이어지는 인자들은 바인드된 함수의 인수에 제공됩니다.

##### **Syntax**

```js title="bind"
func.bind(thisArg[, arg1[, arg2[, ...]]])
```

**Parameters**

`thisArg`

바인딩 함수가 target function의 this에 전달하는 값입니다. strict mode가 아니라면 `null`과 `undefined`는 전역객체로 대체된다. 원시데이터는 객체로 변환된다.

<br />

`arg1, arg2, ...` <CustomOption/>

대상 함수의 파라미터로 사용될 argument.

<br />
<br />

**Return**

지정한 `this`값 및 초기 인수를 사용하여 변경한 원본 함수의 복제본.

<br />
<br />

**Example**

```js title="bind"
const module = {
    x: 42,
    getX: function () {
        return this.x;
    },
};

const unboundGetX = module.getX;
console.log(unboundGetX()); // The function gets invoked at the global scope
// undefined

const boundGetX = unboundGetX.bind(module);
console.log(boundGetX());
// 42
```

###### 새로운 this 무시

```js title="thisArg value is ignored"
function log(...args) {
    console.log(this, ...args);
}

const boundLog = log.bind("this value", 1, 2);
const boundLog2 = boundLog.bind("new this value", 3, 4);
boundLog2(5, 6); // "this value", 1, 2, 3, 4, 5, 6
```

## Scope

스코프는 변수의 유효 범위를 나타내는 프로그래밍 개념이다. 스코프에 따라 변수에 접근하거나 값을 변경할 수 있는 범위가 결정된다.

### [01.] Scope 종류

#### [01-1.] Global scope

전역 스코프는 코드 어디에서든지 접근 가능한 변수의 범위를 의미한다.

#### [01-2.] Local scope

로컬 스코프는 코드 블록 내에서만 변수가 접근 가능한 범위를 의미한다. 이 범위는 함수 내부나 코드 블록{} 내부를 의미한다. 로컬 스코프에서 선언된 변수는 그 범위를 벗어나면 접근할 수 없으며, 메모리에서 사라진다.

##### 로컬 스코프 종류

1. **함수 레벨 스코프** <br/>
   함수 레벨 스코프는 함수 내부에서 선언된 변수가 함수 내부에서만 유효하다는 것을 의미한다. 함수 범위를 벗어나면 해당 변수는 존재하지 않는다. JavaScript(ES6 이전)

1. **블락 레벨 스코프** <br/>
   블락 레벨 스코프는 중괄호\{ \}로 둘러싸인 영역에 선언된 변수가 영역 내에서만 유효하다는 것을 의미한다. C, Java, Python, JavaScript(let, const 키워드) 등이 이에 해당된다.

#### [01-3.] Lexical scope

변수가 **선언된 위치에 의해 그 범위**가 결정되고, **자바스크립트는 렉시컬 스코프**를 따른다.

```js title="Lexical scope"
let y = 5; // global

function alpha() {
    let y = 10;
    console.log(y); // 10
    beta();
}

function beta() {
    console.log(y); // 5
}

alpha();
```

> **MEMO**
>
> -   '선언 위치'라고 해서 '자꾸 작성한 코드 위'라고 생각한다.
> -   실행 컨텍스트에 의해서 beta 함수에 y가 없으니까, 그 하위 컨텍스트인 alpha 함수에서 y 변수를 참조하지 않을까?? 라는 생각이 있었다.
> -   함수 내부에서 beta 함수를 호출했는데 호출된 함수가 전역에 있다면? 함수 내부변수를 참조하지 않고, 전역에 있는 변수를 참조한다. 그러니까 함수가 호출되면 "어디에 선언되어있는지" 확인해야한다. 함수안에 있는 함수인가? 전역에 작성된 함수인가?

## Prototype

자바스크립트 객체는 [[Prototype]]이라는 다른 객체를 가리키는 내부 링크를 가지고 있으며, 이를 통해 속성과 메서드를 상속받는다.
프로토타입은 proto 속성이나 Object.create 메소드를 통해 명시적으로 설정할 수 있다.

> **MEMO**
>
> -   기본적으로 객체는 Object.prototype을 상속 객체로 받는다.

### [01.] 프로토타입 체인

객체에서 특정 속성이나 메서드를 찾을 때, 해당 객체에 없다면 프로토타입 링크를 따라 부모 객체의 프로토타입으로 이동해 찾는다. 이러한 과정을 프로토타입 체인이라고 한다. 이 체인의 끝에는 Object.prototype이 있고, 여기에서도 찾지 못하면 undefined를 반환한다.

### [02.] 프로토타입 상속

자바스크립트에서 모든 객체는 다른 객체의 프로토타입을 상속받을 수 있다. 즉, 객체가 다른 객체의 속성이나 메서드를 사용할 수 있게 된다.

#### [02-1.] 프로토타입 상속 방법

[[Prototype]]은 직접적으로 접근할 수 없다. 아래와 같은 방법으로 [[Prototype]] 상속받을 객체를 지정할 수 있다.

##### \_\_proto\_\_

이 방법은 직접적으로 객체의 \_\_proto\_\_ 속성에 다른 객체를 할당함으로써 상속을 구현한다. 그러나 이 방법은 표준이 아니며, 일부 환경에서는 지원되지 않거나 비효율적일 수 있습니다.

```js title="__proto__"
let point = {
    x: 10,
    y: 20,
};

let point3D = {
    z: 30,
    __proto__: point,
};

console.log(
    point3D.x, // 10, inherited
    point3D.y, // 20, inherited
    point3D.z // 30, own
);
```

##### Object.create()

`Object.create()` 메서드는 새로운 객체를 생성하면서 첫 번째 인자로 전달된 객체를 생성된 객체의 프로토타입으로 설정한다. 이 방법은 표준 방식이며, 명시적이고 안전한 방법으로 널리 사용된다.

##### **Syntax**

```js title="Object.create()"
Object.create(proto[, propertiesObject])
```

**Parameters**

`proto`

상속받을 객체.

<br />

`propertiesObject` <CustomOption/>

객체의 프로퍼티를 정의하는 객체. 옵션

<br />
<br />

**Return**

지정된 프로토타입 및 속성을 갖는 새로운 객체.

<br />
<br />

**Example**

```js title="Object.create()"
let protoA = { x: 10 };
let protoB = { x: 20 };

let objectC = Object.create(protoA);
console.log(objectC.x);
// 10
```

###### 상속 받지 않기

객체는 항상 Object.prototype으로부터 무언가를 상속받기 때문에 기본 객체는 실제로 비어있지 않다. 아무것도 상속 받지 않기 위해서는 null로 설정해야 한다.

```js title="Object.create(null)"
let dict = Object.create(null);

console.log(dict.toString);
// undefined
```

## Closure

클로저는 함수가 자신이 선언됐을 때의 환경을 **기억**하게 한다.

```js title="closure"
function makeAdder(x) {
    return function (y) {
        return x + y;
    };
}

const add5 = makeAdder(5);
const add10 = makeAdder(10);

console.log(add5(2)); // 7
console.log(add10(2)); // 12
```

### [01.] 클로져 특징

#### [01-1.] 외부 함수의 지역 변수에 접근

클로저를 사용하면, 한 함수 내에서 선언된 다른 함수(내부 함수)가 외부 함수의 지역 변수에 접근할 수 있다.

#### [01-2.] 데이터 은닉과 캡슐화

클로저를 활용하면, 객체 지향 프로그래밍의 데이터 은닉과 유사한 효과를 낼 수 있다. 함수 외부에서 직접 접근할 수 없는 변수를 만들어, 함수를 통해서만 해당 변수를 조작할 수 있도록 할 수 있다.

```js title="encapsulation"
function createCounter() {
    let count = 0;

    return {
        increment: function () {
            count++;
            return count;
        },
        decrement: function () {
            count--;
            return count;
        },
    };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.decrement()); // 1
```

#### [01-3.] 상태 유지

클로저는 함수가 호출될 때마다 상태를 유지할 수 있다. 예를 들어, 클로저를 이용하면 함수 호출 사이에 어떤 값을 기억하고 이를 기반으로 계산을 수행할 수 있다.

```js title="state"
function createUniqueIdGenerator() {
    let id = 0;

    return function () {
        id += 1;
        return id;
    };
}

const generateId = createUniqueIdGenerator();
console.log(generateId()); // 1
console.log(generateId()); // 2
console.log(generateId()); // 3
```

###### 레퍼런스

-   https://www.dev-bbak.site/blog/JS/executionContext

<CustomContents contents={["실행컨텍스트", "this", "scope", "prototype", "closure"]} />
